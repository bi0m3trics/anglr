% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesh3d.R
\name{as.mesh3d}
\alias{as.mesh3d}
\alias{as.mesh3d.TRI}
\alias{as.mesh3d.TRI0}
\alias{as.mesh3d.matrix}
\alias{as.mesh3d.BasicRaster}
\alias{as.mesh3d.QUAD}
\title{Mesh3d objects}
\usage{
\method{as.mesh3d}{TRI}(
  x,
  z,
  smooth = FALSE,
  normals = NULL,
  texcoords = NULL,
  ...,
  keep_all = TRUE,
  image_texture = NULL,
  meshColor = "faces"
)

\method{as.mesh3d}{TRI0}(
  x,
  z,
  smooth = FALSE,
  normals = NULL,
  texcoords = NULL,
  ...,
  keep_all = TRUE,
  image_texture = NULL,
  meshColor = "faces"
)

\method{as.mesh3d}{matrix}(
  x,
  triangles = FALSE,
  smooth = FALSE,
  normals = NULL,
  texcoords = NULL,
  ...
)

\method{as.mesh3d}{BasicRaster}(x, triangles = FALSE, ...)

\method{as.mesh3d}{QUAD}(
  x,
  triangles = FALSE,
  smooth = FALSE,
  normals = NULL,
  texcoords = NULL,
  ...
)
}
\arguments{
\item{x}{An object of class \code{TRI} or \code{TRI0}}

\item{z}{numeric vector or raster object (see details)}

\item{smooth}{
Whether to average normals at vertices for
a smooth appearance.
}

\item{normals}{
User-specified normals at each vertex.  Requires \code{smooth = FALSE}.
}

\item{texcoords}{
Texture coordinates at each vertex.
}

\item{...}{arguments collected and passed to \code{\link[rgl:tmesh3d]{rgl::tmesh3d()}} as the \code{material} argument}

\item{keep_all}{whether to keep non-visible triangles}

\item{image_texture}{an rgb object to texture the surface}

\item{meshColor}{how should colours be interpreted? 'vertices' or 'faces', for more
details see \link[rgl:tmesh3d]{rgl::tmesh3d}.}

\item{triangles}{for quad input types, the quads may optionally be split into triangles}
}
\value{
a \href{rgl::mesh3d}{mesh3d object}
}
\description{
Methods for the mesh3d type from package rgl
}
\details{
The 'z' argument can be a constant value or a vector of values to be
used for each vertex. Alternatively, it may be a spatial raster object
from which 'z' values are derived. If not set, the vertex 'z_' value
from TRI/TRI0 is used, otherwise z = 0' is assumed.
}
\examples{
sf <- silicate::minimal_mesh
#sf <- silicate::inlandwaters
x <- silicate::TRI(sf)
library(rgl)
clear3d(); plot3d(x); view3d(phi = -10)
## simple convention to carry feature colours
sf$color_ <- c("firebrick", "dodgerblue")
clear3d(); plot3d(silicate::TRI(sf)); view3d(phi = -10)

# material properties for $material are collected in ...
# and will override the 'color_' mech
x$object$color_ <- "black"
clear3d(); plot3d(as.mesh3d(x, color = rainbow(14)))

## we cannot assume TRI triangles relate to features simply
##  but sometimes it does  (always does for TRI0)
cols <- c("black", "grey")[c(rep(1, 12), c(2, 2))]
clear3d(); plot3d(as.mesh3d(x, color = cols))

## smear by vertices meshColor
cols <- c("black", "grey")
clear3d(); plot3d(as.mesh3d(x, color = cols), meshColor = "vertices")

## other material properties
clear3d(); plot3d(as.mesh3d(x, color = cols, specular = "black"), meshColor = "vertices")
clear3d(); plot3d(as.mesh3d(x, color = cols, front = "lines", lwd = 5), meshColor = "vertices")
clear3d(); plot3d(as.mesh3d(x, color = viridis::viridis(20), alpha = 0.3), meshColor = "faces")
clear3d(); plot3d(as.mesh3d(x, color = viridis::viridis(5), alpha = 0.3), meshColor = "vertices")

# TRI0 - index is stored structurally, not relations
x0 <- silicate::TRI0(sf)
clear3d(); plot3d(x0); view3d(phi = -10)

# (TRI0 - it *is* guaranteed that triangle order is native)
clear3d(); plot3d(as.mesh3d(x0,  material = list(color = rainbow(14))))

## arbitrarily drape polygons over raster
r <- raster::setExtent(raster::raster(volcano), raster::extent(-0.1, 1.1, -0.1, 1.1))
clear3d();shade3d(as.mesh3d(DEL(silicate::minimal_mesh, max_area = 0.001), z =r))
aspect3d(1, 1, 0.5)

library(rgl)
r1 <- raster::setExtent(raster::raster(volcano), raster::extent(silicate::inlandwaters))
clear3d();shade3d(as.mesh3d(DEL(silicate::inlandwaters, max_area = 1e9), z =r1))
aspect3d(1, 1, .2)

## fake news
rgl::wire3d(as.mesh3d(r1))

}
